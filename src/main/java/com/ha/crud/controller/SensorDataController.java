package com.ha.crud.controller;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.ha.crud.entity.SensorData;
import com.ha.crud.repo.SensorDataRepo;

@Controller    // This means that this class is a Controller
@RequestMapping(path="/sensorData") // This means URL's start with /sensorData (after Application path)
public class SensorDataController {
	private static final Logger logger = LoggerFactory.getLogger(SensorDataController.class);

	// This means to get the bean called SensorDataRepo
	// Which is auto-generated by Spring, we will use it to handle the data
	@Autowired 
	private SensorDataRepo sensorDataRepo;

	/**
	 * rest endpoint to get all SensorData
	 * @return
	 */
	@GetMapping(path="/all")
	public @ResponseBody Iterable<SensorData> getAllData() {
		logger.debug("get request to /all path made");
		return sensorDataRepo.findAll();
	}


	/**
	 * rest endpoint to add list of data in DB
	 * @param sensorDataValues
	 * @return
	 */
	@PostMapping(path="/addData")
	public @ResponseBody String addDataToDb(@RequestBody List<SensorData> sensorDataValues) {
		logger.debug("post request to /addData path made sensorData : "+sensorDataValues);
		sensorDataRepo.saveAll(sensorDataValues);
		return "{\" batch save success\"}";
	}

	/**
	 * rest endpoint to get csv file or latest data in csv format
	 * @param activity
	 * @param subject
	 * @param type
	 * @return
	 */
	@GetMapping(path="/getCsv")
	public @ResponseBody String getAllDataCsv(@RequestParam(required=false) String activity,@RequestParam(required=false) String subject,@RequestParam String type) {
		logger.debug("get request to /getCsv path made");
		if("rest".equals(type)) {
			return printCsv();
		}else {
			return printFile(activity, subject);
		}
	}


	@GetMapping(path="/getPlotData")
	public @ResponseBody String getPlotDataCsv() throws IOException {
		logger.debug("get request to /getPlotData path made");
		SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
		String dateString = format.format(new Date(System.currentTimeMillis() - 300000+3600000));
		Iterable<SensorData> sensorDataForPlot = sensorDataRepo.findByDate(dateString);
		if(sensorDataForPlot==null || !sensorDataForPlot.iterator().hasNext()) {
			return "";
		}
		CSVPrinter csvPrinter = null;
		StringWriter sw = new StringWriter();
		csvPrinter = new CSVPrinter(sw, CSVFormat.DEFAULT.withHeader(
				"createTime","xcoor","ycoor","zcoor","xaxis","yaxis","zaxis"));
		for(SensorData sd:sensorDataForPlot) {
			csvPrinter.printRecord(sd.getCreateTime(),sd.getxCoor(),sd.getyCoor(),sd.getzCoor(),sd.getxAxis(),sd.getyAxis(),sd.getzAxis());
		}
		sw.flush();
		csvPrinter.close();
		return sw.toString();
	}

	/**
	 * rest endpoint to delete all data
	 * @return
	 */
	@GetMapping(path="/deleteAll")
	public @ResponseBody String deleteAllData() {
		sensorDataRepo.deleteAll();
		return "Success";
	}

	/**
	 * Will print all activity data to a file. This will then be used to train data
	 * @param activity
	 * @param subject
	 * @return
	 */
	private String printFile(String activity, String subject) {
		String fileName = "C:\\"+activity+"_"+subject+".csv";
		Iterable<SensorData> allSD = sensorDataRepo.findAll();
		try {
			CSVPrinter csvPrinter = null;
			BufferedWriter writer = Files.newBufferedWriter(Paths.get(fileName));
			csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
					"tBodyAcc-mean()-X","tBodyAcc-mean()-Y","tBodyAcc-mean()-Z","tBodyAcc-max()-X","tBodyAcc-max()-Y"
					,"tBodyAcc-max()-Z","tBodyGyro-mean()-X","tBodyGyro-mean()-Y","tBodyGyro-mean()-Z",
					"subject","Activity"));

			List<SensorData> sensorDataList = new ArrayList<>();
			for(SensorData sd:allSD) {
				sensorDataList.add(sd);
			}
			Collections.sort(sensorDataList,new SortbyDate());
			Date batchDate = sensorDataList.get(0).getCreateTime();
			List<SensorData> sdBatch = new ArrayList<>();
			for(SensorData sd : sensorDataList) {
				long diff = sd.getCreateTime().getTime() - batchDate.getTime();
				long diffMinutes = diff / (1000);         
				if(diffMinutes<3) {
					sdBatch.add(sd);
				}else {
					Double xCoorMax=0d,yCoorMax=0d,zCoorMax=0d,xCoorMean,yCoorMean,zCoorMean,xAxisMean,yAxisMean,zAxisMean;
					Double xCoorSum=0d,yCoorSum=0d,zCoorSum=0d,xAxisSum=0d,yAxisSum=0d,zAxisSum=0d;
					int coorTotal=0,axisTotal=0;
					for(SensorData sd1: sdBatch) {
						if(xCoorMax<sd1.getxCoor()) {
							xCoorMax = sd1.getxCoor();
						}
						if(yCoorMax<sd1.getyCoor()) {
							yCoorMax = sd1.getyCoor();
						}
						if(zCoorMax<sd1.getzCoor()) {
							zCoorMax = sd1.getzCoor();
						}
						if(sd1.getxCoor()!=0) {
							coorTotal++;
							xCoorSum+=sd1.getxCoor();yCoorSum+=sd1.getyCoor();zCoorSum+=sd1.getzCoor();
						}
						if(sd1.getxAxis()!=0) {
							axisTotal++;
							xAxisSum+=sd1.getxAxis();yAxisSum+=sd1.getyAxis();zAxisSum+=sd1.getzAxis();
						}
					}
					xCoorMean=(Double)xCoorSum/coorTotal;yCoorMean=(Double)yCoorSum/coorTotal;zCoorMean=(Double)zCoorSum/coorTotal;
					xAxisMean=(Double)xAxisSum/axisTotal;yAxisMean=(Double)yAxisSum/axisTotal;zAxisMean=(Double)zAxisSum/axisTotal;
					if(coorTotal>0&&axisTotal>0)
						csvPrinter.printRecord(""+xCoorMean,""+yCoorMean,""+zCoorMean,""+xCoorMax,""+yCoorMax,""+zCoorMax,
								""+xAxisMean,""+yAxisMean,""+zAxisMean,subject,activity);

					// batch cleanup
					sdBatch.clear();
					sdBatch.add(sd);
					batchDate=sd.getCreateTime();
					xCoorSum=0d;yCoorSum=0d;zCoorSum=0d;xAxisSum=0d;yAxisSum=0d;zAxisSum=0d;
					coorTotal=0;axisTotal=0;
					xCoorMax=0d;yCoorMax=0d;zCoorMax=0d;
				}
			}
			writer.flush();
			csvPrinter.close();
		} catch (IOException e) {
			e.printStackTrace();
		}


		return "file write success";
	}


	/**
	 * Will return last 3 second data to be used to predict user activity
	 * @return
	 */
	private String printCsv() {
		SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
		String dateString = format.format(new Date(System.currentTimeMillis() - 3000+3600000));
		Iterable<SensorData> allSD = sensorDataRepo.findByDate(dateString);
		try {
			CSVPrinter csvPrinter = null;
			StringWriter sw = new StringWriter();
			csvPrinter = new CSVPrinter(sw, CSVFormat.DEFAULT.withHeader(
					"tBodyAcc.mean...X","tBodyAcc.mean...Y","tBodyAcc.mean...Z","tBodyAcc.max...X","tBodyAcc.max...Y"
					,"tBodyAcc.max...Z","tBodyGyro.mean...X","tBodyGyro.mean...Y","tBodyGyro.mean...Z"));

			List<SensorData> sensorDataList = new ArrayList<>();
			for(SensorData sd:allSD) {
				sensorDataList.add(sd);
			}
			if(sensorDataList.isEmpty()) {
				csvPrinter.close();
				sw.flush();
				return "";
			}

			Double xCoorMax=0d,yCoorMax=0d,zCoorMax=0d,xCoorMean=0d,yCoorMean=0d,zCoorMean=0d,xAxisMean=0d,yAxisMean=0d,zAxisMean=0d;
			Double xCoorSum=0d,yCoorSum=0d,zCoorSum=0d,xAxisSum=0d,yAxisSum=0d,zAxisSum=0d;
			int coorTotal=0,axisTotal=0;
			for(SensorData sd : sensorDataList) {
				if(xCoorMax<sd.getxCoor()) {
					xCoorMax = sd.getxCoor();
				}
				if(yCoorMax<sd.getyCoor()) {
					yCoorMax = sd.getyCoor();
				}
				if(zCoorMax<sd.getzCoor()) {
					zCoorMax = sd.getzCoor();
				}
				if(sd.getxCoor()!=0) {
					coorTotal++;
					xCoorSum+=sd.getxCoor();yCoorSum+=sd.getyCoor();zCoorSum+=sd.getzCoor();
				}
				if(sd.getxAxis()!=0) {
					axisTotal++;
					xAxisSum+=sd.getxAxis();yAxisSum+=sd.getyAxis();zAxisSum+=sd.getzAxis();
				}
				xCoorMean=(Double)xCoorSum/coorTotal;yCoorMean=(Double)yCoorSum/coorTotal;zCoorMean=(Double)zCoorSum/coorTotal;
				xAxisMean=(Double)xAxisSum/axisTotal;yAxisMean=(Double)yAxisSum/axisTotal;zAxisMean=(Double)zAxisSum/axisTotal;
			}
			if(coorTotal>0&&axisTotal>0)
				csvPrinter.printRecord(""+xCoorMean,""+yCoorMean,""+zCoorMean,""+xCoorMax,""+yCoorMax,""+zCoorMax,
						""+xAxisMean,""+yAxisMean,""+zAxisMean);
			sw.flush();
			csvPrinter.close();
			return sw.toString();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return "failed";
	}


	/**
	 * comparator to be used to sort Sensor data by date in desc order. latest date sensroData will be greater
	 * @author eankuba
	 *
	 */
	class SortbyDate implements Comparator<SensorData> 
	{ 
		public int compare(SensorData a, SensorData b) 
		{ 
			return a.getCreateTime().compareTo(b.getCreateTime()); 
		} 
	} 
}